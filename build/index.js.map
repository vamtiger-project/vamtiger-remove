{"version":3,"file":"index.js","sources":["../source/remove-paths.ts","../source/get-temp-folder.ts","../source/get-paths-to-exclude.ts","../source/archive-path.ts","../source/archive-paths.ts","../source/unarchive.ts","../source/remove-file.ts","../source/remove-folder-path.ts","../source/remove-path.ts","../source/remove-folder.ts","../source/remove.ts","../source/index.ts"],"sourcesContent":["import { RemoveFiles } from '.';\n\nconst remove = require('trash');\n\nexport default async function ({ paths }: RemoveFiles.Params) {\n    const result = paths && await remove(paths);\n\n    return result;\n}","import { mkdtemp } from 'fs';\nimport { tmpdir } from 'os';\nimport { resolve as resolvePath } from 'path';\nimport { IGetTempFolder } from '.';\n\nexport default ({ path: folder }: IGetTempFolder['params']) => new Promise((resolve, reject) => {\n    const tempFolder = resolvePath(\n        tmpdir(),\n        folder\n    );\n\n    mkdtemp(tempFolder, (error, folder) => error ? reject(error) : resolve(folder))\n}) as Promise<string>;","import { IGetPathsToExclude } from '.';\n\nexport default function ({ paths, regex }: IGetPathsToExclude['params']) {\n    const pathsToExclude = new Set<string>();\n\n    let excludePath: boolean;\n\n    paths.forEach(currentPath => {\n        excludePath = !pathsToExclude.has(currentPath) && regex.some(currentRegex => currentPath.match(currentRegex) ? true : false);\n\n        if (excludePath) {\n            pathsToExclude.add(currentPath);\n        }\n    });\n\n    return Array.from(pathsToExclude);\n}","import { dirname, basename, resolve as resolvePath } from 'path';\nimport getPathData from 'vamtiger-get-path-data';\nimport createFolder from 'vamtiger-create-directory-recursive';\nimport copyFile from 'vamtiger-copy-file';\nimport { IArchivePath } from '.';\n\nexport default async function({ path: currentPath, archiveFolder, folderPath: sourceFolderPath }: IArchivePath['params']) {\n    const pathData = await getPathData(currentPath);\n    const filePath = pathData.isFile() && currentPath;\n    const archiveFilePath = filePath && filePath.replace(sourceFolderPath, archiveFolder);\n    const folderPath = archiveFilePath && dirname(archiveFilePath) || currentPath.replace(sourceFolderPath, archiveFolder);\n\n    if (folderPath) {\n        await createFolder({\n            path: folderPath\n        });\n    }\n\n    if (filePath && archiveFilePath) {\n        await copyFile({\n            source: filePath,\n            destination: archiveFilePath\n        });\n    }\n}","import archivePath from './archive-path';\nimport { IArchivePaths } from '.';\n\nexport default function ({ paths, archiveFolder, folderPath }: IArchivePaths['params']) {\n    const archivePaths = paths.reduce((archive, currentPath) => archive.then(() => archivePath({\n        path: currentPath,\n        folderPath,\n        archiveFolder\n    })), Promise.resolve());\n\n    return archivePaths;\n}","import getFolderContent from 'vamtiger-get-directory-content-recursive';\nimport createFolder from 'vamtiger-create-directory-recursive';\nimport copyFile from 'vamtiger-copy-file';\nimport { IUnArchive } from '.';\n\n\nexport default async function ({ archiveFolder, unarchivedFolder }: IUnArchive['params']) {\n    const { file: archivedFiles = [], directory: archiveFolders = [] } = await getFolderContent({\n        path: archiveFolder,\n        classified: true\n    }) as { file: string[], directory: string[]};\n    const unarchivedFoldersPaths = archiveFolders.map(currentArchivedFolder => currentArchivedFolder.replace(archiveFolder, unarchivedFolder));\n    const copyFilePaths = archivedFiles.map(currentArchivedFile => ({\n        source: currentArchivedFile,\n        destination: currentArchivedFile.replace(archiveFolder, unarchivedFolder)\n    }));\n    const unarchivedFolders = unarchivedFoldersPaths.length && unarchivedFoldersPaths.reduce((unarchive, currentPath) => unarchive.then(() => createFolder({\n            path: currentPath\n        })), Promise.resolve())\n        ||\n        createFolder({\n            path: unarchivedFolder\n        });\n\n    await unarchivedFolders;\n\n    await Promise.all(copyFilePaths.map(copyFile));\n}","import { unlink as removeFile } from 'fs';\nimport {\n    RemoveFile\n} from '.';\n\nexport default ({ path: filePath }: RemoveFile.Params) => new Promise((resolve, reject) =>\n    removeFile(filePath, error => error ? reject(error) : resolve())\n);","import { rmdir as removeFolder } from 'fs';\nimport { IRemoveFolderPath } from '.';\n\nexport default ({ path: folderPath }: IRemoveFolderPath['params']) => new Promise((resolve, reject) =>\n    removeFolder(folderPath, error => error ? reject(error) : resolve())\n) as Promise<void>;","import getFolderContent from 'vamtiger-get-directory-content-recursive';\nimport getPathData from 'vamtiger-get-path-data';\nimport removeFile from './remove-file';\nimport removeFolder from './remove-folder-path';\nimport { IRemovePath } from '.';\nimport { promises } from 'fs';\n\nexport default async function ({ path: currentPath}: IRemovePath['params']) {\n    const pathData = await getPathData(currentPath);\n    const { file = [], directory = [] } = await getFolderContent({\n        path: currentPath,\n        classified: true\n    }) as { file: string[], directory: string[]};\n    const files = new Set(pathData.isFile() ? file.concat([currentPath]) : file);\n    const folders = new Set(\n        directory\n            .reverse()\n            .concat([currentPath])\n    );\n\n    await Promise.all(Array.from(files).map(filePath => removeFile({\n        path: filePath\n    })));\n\n    await Array\n        .from(folders)\n        .reduce((removeCurrentFolder, folderPath) => removeCurrentFolder.then(() => removeFolder({\n            path: folderPath\n        })), Promise.resolve());\n}","import { basename, resolve as resolvePath } from 'path';\nimport getFolderContent from 'vamtiger-get-directory-content-recursive';\nimport removePaths from './remove-paths';\nimport getTempFolder from './get-temp-folder';\nimport getPathsToExclude from './get-paths-to-exclude';\nimport archivePaths from './archive-paths';\nimport unarchive from './unarchive';\nimport permanentRemove from './remove-path';\nimport { RemoveFolder } from '.';\n\nexport default async function ({ path: folderPath, exclude, excludePattern = '' }: RemoveFolder.Params) {\n    const excludePatterns = (exclude && typeof exclude === 'string' && [exclude] || exclude || []) as string[];\n    const patterns = excludePatterns\n        .map(pattern => `^${resolvePath(folderPath, pattern)}$`)\n        .concat([excludePattern])\n        .filter(pattern => pattern) as string[];\n    const excludeRegex = patterns.map(pattern => new RegExp(pattern));\n    const tempFolder = await getTempFolder({\n        path: basename(folderPath)\n    });\n    const folderContent = await getFolderContent({ path: folderPath }) as string[];\n    const pathsToExclude = getPathsToExclude({\n        paths: folderContent,\n        regex: excludeRegex\n    });\n\n    await archivePaths({\n        paths: pathsToExclude,\n        folderPath,\n        archiveFolder: tempFolder\n    });\n\n    await removePaths({\n        paths: [folderPath]\n    });\n\n    await unarchive({\n        archiveFolder: tempFolder,\n        unarchivedFolder: folderPath\n    });\n\n    await permanentRemove({\n        path: tempFolder\n    });\n}","import removePaths from './remove-paths';\nimport removeFolder from './remove-folder';\nimport {\n    Remove\n} from '.';\n\nexport default async function remove({ file, files, folder, exclude, excludePattern }: Remove.Params) {\n    if (file) {\n        await removePaths({\n            paths: [file]\n        });\n    } else if (files) {\n        await removePaths({\n            paths: files\n        });\n    } else if (folder) {\n        await removeFolder({\n            path: folder,\n            exclude,\n            excludePattern\n        });\n    }\n}","import { promisify } from 'util';\nimport { unlink, rmdir, PathLike } from 'fs';\nimport { ClassifiedDirectoryContent } from 'vamtiger-get-directory-content-recursive/build/directory-content';\nimport remove from './remove';\n\nexport type DirectoryContent = {\n    [K in keyof ClassifiedDirectoryContent]?: ClassifiedDirectoryContent[K];\n};\n\nexport type DirectoryContentKey = keyof ClassifiedDirectoryContent;\n\nexport type CurrentDirectoryContent = ClassifiedDirectoryContent[DirectoryContentKey] | string[] | undefined;\n\nexport enum CommandlineArg {\n    file = 'file',\n    folder = 'folder',\n    exclude = 'exclude',\n    excludePattern = 'excludePattern',\n    help = 'help'\n}\n\nexport enum AbbreviatedCommandlineArg {\n    f = 'f',\n    d = 'd',\n    e = 'e',\n    p = 'p',\n    h = 'h'\n}\n\nexport const ShortCommandlineArgs = {\n    [CommandlineArg.file]: AbbreviatedCommandlineArg.f,\n    [CommandlineArg.folder]: AbbreviatedCommandlineArg.d,\n    [CommandlineArg.exclude]: AbbreviatedCommandlineArg.e,\n    [CommandlineArg.excludePattern]: AbbreviatedCommandlineArg.p,\n    [CommandlineArg.help]: AbbreviatedCommandlineArg.h\n}\n\nexport const CommandlineDescription = {\n    [CommandlineArg.file]: 'File to remove',\n    [CommandlineArg.folder]: 'Folder to remove',\n    [CommandlineArg.exclude]: 'File/Folder to exclude',\n    [CommandlineArg.excludePattern]: 'File/Folder pattern to exclude',\n    [CommandlineArg.help]: 'List help options'\n}\n\nexport namespace RemoveFile {\n    export type Params = {\n        path: PathLike;\n    }\n}\n\nexport namespace RemoveFiles {\n    export type Params = {\n        paths: Remove.Params['files'];\n    }\n}\n\nexport namespace RemoveFolder {\n    export type Params = {\n        path: string;\n        exclude: Remove.Params['exclude'];\n        excludePattern: Remove.Params['excludePattern'];\n    }\n}\n\nexport namespace GetFilePath {\n    export type Params = {\n        path: string;\n    }\n}\n\nexport namespace GetFolderContent {\n    export type Params = {\n        folderPath: RemoveFolder.Params['path'];\n        exclude?: string;\n        excludePattern?: string;\n    }\n}\n\nexport namespace Remove {\n    export type Params = {\n        file?: string;\n        folder?: string;\n        files?: string[];\n        recursive?: boolean;\n        exclude?: string | string[];\n        excludePattern?: string;\n    }\n}\n\nexport interface IGetTempFolder {\n    params: {\n        path: string;\n    }\n}\n\nexport interface IGetPathsToExclude {\n    params: {\n        paths: string[];\n        regex: RegExp[];\n    }\n}\n\nexport interface IArchivePaths {\n    params: {\n        paths: string[];\n        folderPath: string;\n        archiveFolder: string;\n    }\n}\n\nexport interface IArchivePath {\n    params: {\n        path: string;\n        folderPath: string;\n        archiveFolder: string;\n    }\n}\n\nexport interface IUnArchive {\n    params: {\n        archiveFolder: string;\n        unarchivedFolder: string;\n    }\n}\n\nexport interface IRemovePath {\n    params: {\n        path: string;\n    }\n}\n\nexport interface IRemoveFolderPath {\n    params: {\n        path: string;\n    }\n}\n\nexport default remove;"],"names":["remove","require","async","paths","path","folder","Promise","resolve","reject","tempFolder","resolvePath","tmpdir","mkdtemp","error","regex","pathsToExclude","Set","excludePath","forEach","currentPath","has","some","currentRegex","match","add","Array","from","archiveFolder","folderPath","sourceFolderPath","filePath","getPathData","isFile","archiveFilePath","replace","dirname","createFolder","copyFile","source","destination","reduce","archive","then","archivePath","unarchivedFolder","file","archivedFiles","directory","archiveFolders","getFolderContent","classified","unarchivedFoldersPaths","map","currentArchivedFolder","copyFilePaths","currentArchivedFile","unarchivedFolders","length","unarchive","all","removeFile","removeFolder","pathData","files","concat","folders","reverse","removeCurrentFolder","exclude","excludePattern","excludeRegex","pattern","filter","RegExp","getTempFolder","basename","getPathsToExclude","archivePaths","removePaths","permanentRemove","CommandlineArg","AbbreviatedCommandlineArg","ShortCommandlineArgs","[object Object]","f","d","e","p","help","h","CommandlineDescription"],"mappings":"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"}