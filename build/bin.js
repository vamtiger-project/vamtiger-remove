#!/usr/bin/env node
"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var fs=require("fs"),os=require("os"),path=require("path"),getPathData=_interopDefault(require("vamtiger-get-path-data")),createFolder=_interopDefault(require("vamtiger-create-directory-recursive")),copyFile=_interopDefault(require("vamtiger-copy-file")),getFolderContent=_interopDefault(require("vamtiger-get-directory-content-recursive")),Args=_interopDefault(require("vamtiger-argv/build/main")),getHelp=_interopDefault(require("vamtiger-commandline-help"));function __awaiter(e,r,t,n){return new(t||(t=Promise))(function(a,o){function i(e){try{d(n.next(e))}catch(e){o(e)}}function l(e){try{d(n.throw(e))}catch(e){o(e)}}function d(e){e.done?a(e.value):new t(function(r){r(e.value)}).then(i,l)}d((n=n.apply(e,r)).next())})}const remove=require("trash");function removePaths({paths:e}){return __awaiter(this,void 0,void 0,function*(){return e&&(yield remove(e))})}var getTempFolder=({path:e})=>new Promise((r,t)=>{const n=path.resolve(os.tmpdir(),e);fs.mkdtemp(n,(e,n)=>e?t(e):r(n))});function getPathsToExclude({paths:e,regex:r}){const t=new Set;let n;return e.forEach(e=>{(n=!t.has(e)&&r.some(r=>!!e.match(r)))&&t.add(e)}),Array.from(t)}function archivePath({path:e,archiveFolder:r,folderPath:t}){return __awaiter(this,void 0,void 0,function*(){const n=(yield getPathData(e)).isFile()&&e,a=n&&n.replace(t,r),o=a&&path.dirname(a)||e.replace(t,r);o&&(yield createFolder({path:o})),n&&a&&(yield copyFile({source:n,destination:a}))})}function archivePaths({paths:e,archiveFolder:r,folderPath:t}){return e.reduce((e,n)=>e.then(()=>archivePath({path:n,folderPath:t,archiveFolder:r})),Promise.resolve())}function unarchive({archiveFolder:e,unarchivedFolder:r}){return __awaiter(this,void 0,void 0,function*(){const{file:t=[],directory:n=[]}=yield getFolderContent({path:e,classified:!0}),a=n.map(t=>t.replace(e,r)),o=t.map(t=>({source:t,destination:t.replace(e,r)}));yield a.length&&a.reduce((e,r)=>e.then(()=>createFolder({path:r})),Promise.resolve())||createFolder({path:r}),yield Promise.all(o.map(copyFile))})}var CommandlineArg,AbbreviatedCommandlineArg,removeFile=({path:e})=>new Promise((r,t)=>fs.unlink(e,e=>e?t(e):r())),removeFolder=({path:e})=>new Promise((r,t)=>fs.rmdir(e,e=>e?t(e):r()));function permanentRemove({path:e}){return __awaiter(this,void 0,void 0,function*(){const r=yield getPathData(e),{file:t=[],directory:n=[]}=yield getFolderContent({path:e,classified:!0}),a=new Set(r.isFile()?t.concat([e]):t),o=new Set(n.reverse().concat([e]));yield Promise.all(Array.from(a).map(e=>removeFile({path:e}))),yield Array.from(o).reduce((e,r)=>e.then(()=>removeFolder({path:r})),Promise.resolve())})}function removeFolder$1({path:e,exclude:r,excludePattern:t=""}){return __awaiter(this,void 0,void 0,function*(){const n=(r&&"string"==typeof r&&[r]||r||[]).map(r=>`^${path.resolve(e,r)}$`).concat([t]).filter(e=>e).map(e=>new RegExp(e)),a=yield getTempFolder({path:path.basename(e)});yield archivePaths({paths:getPathsToExclude({paths:yield getFolderContent({path:e}),regex:n}),folderPath:e,archiveFolder:a}),yield removePaths({paths:[e]}),yield unarchive({archiveFolder:a,unarchivedFolder:e}),yield permanentRemove({path:a})})}function remove$1({file:e,files:r,folder:t,exclude:n,excludePattern:a}){return __awaiter(this,void 0,void 0,function*(){e?yield removePaths({paths:[e]}):r?yield removePaths({paths:r}):t&&(yield removeFolder$1({path:t,exclude:n,excludePattern:a}))})}!function(e){e.file="file",e.folder="folder",e.exclude="exclude",e.excludePattern="excludePattern",e.help="help"}(CommandlineArg||(CommandlineArg={})),function(e){e.f="f",e.d="d",e.e="e",e.p="p",e.h="h"}(AbbreviatedCommandlineArg||(AbbreviatedCommandlineArg={}));const ShortCommandlineArgs={[CommandlineArg.file]:AbbreviatedCommandlineArg.f,[CommandlineArg.folder]:AbbreviatedCommandlineArg.d,[CommandlineArg.exclude]:AbbreviatedCommandlineArg.e,[CommandlineArg.excludePattern]:AbbreviatedCommandlineArg.p,[CommandlineArg.help]:AbbreviatedCommandlineArg.h},CommandlineDescription={[CommandlineArg.file]:"File to remove",[CommandlineArg.folder]:"Folder to remove",[CommandlineArg.exclude]:"File/Folder to exclude",[CommandlineArg.excludePattern]:"File/Folder pattern to exclude",[CommandlineArg.help]:"List help options"},workingDirectory=process.cwd(),args=new Args,currentFiles=args.has(CommandlineArg.file)&&args.getAll(CommandlineArg.file)||args.has(ShortCommandlineArgs[CommandlineArg.file])&&args.getAll(ShortCommandlineArgs[CommandlineArg.file]),currrentFolder=args.has(CommandlineArg.folder)&&args.get(CommandlineArg.folder)||args.has(ShortCommandlineArgs[CommandlineArg.folder])&&args.get(ShortCommandlineArgs[CommandlineArg.folder]),currentExclude=args.has(CommandlineArg.exclude)&&args.getAll(CommandlineArg.exclude)||args.has(ShortCommandlineArgs[CommandlineArg.exclude])&&args.getAll(ShortCommandlineArgs[CommandlineArg.exclude]),currrentFolderPattern=args.has(CommandlineArg.excludePattern)&&args.get(CommandlineArg.excludePattern)||args.has(ShortCommandlineArgs[CommandlineArg.excludePattern])&&args.get(ShortCommandlineArgs[CommandlineArg.excludePattern]),help=(args.has(CommandlineArg.help)||args.has(ShortCommandlineArgs[CommandlineArg.help]))&&getHelp({args:Object.assign(CommandlineArg),short:ShortCommandlineArgs,description:CommandlineDescription}),removeParams=(currentFiles||currrentFolder)&&{files:currentFiles&&currentFiles.map(e=>path.resolve(workingDirectory,e)),folder:path.resolve(workingDirectory,currrentFolder),exclude:currentExclude,excludePattern:currrentFolderPattern};function handleError(e){console.trace(e),process.exit()}help?console.log(help):removeParams&&remove$1(removeParams).catch(handleError);
//# sourceMappingURL=bin.js.map
