"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var fs=require("fs"),os=require("os"),path=require("path"),getPathData=_interopDefault(require("vamtiger-get-path-data")),createFolder=_interopDefault(require("vamtiger-create-directory-recursive")),copyFile=_interopDefault(require("vamtiger-copy-file")),getFolderContent=_interopDefault(require("vamtiger-get-directory-content-recursive"));const remove=require("trash");async function removePaths({paths:e}){return e&&await remove(e)}var getTempFolder=({path:e})=>new Promise((t,a)=>{const r=path.resolve(os.tmpdir(),e);fs.mkdtemp(r,(e,r)=>e?a(e):t(r))});function getPathsToExclude({paths:e,regex:t}){const a=new Set;let r;return e.forEach(e=>{(r=!a.has(e)&&t.some(t=>!!e.match(t)))&&a.add(e)}),Array.from(a)}async function archivePath({path:e,archiveFolder:t,folderPath:a}){const r=(await getPathData(e)).isFile()&&e,o=r&&r.replace(a,t),i=o&&path.dirname(o)||e.replace(a,t);i&&await createFolder({path:i}),r&&o&&await copyFile({source:r,destination:o})}function archivePaths({paths:e,archiveFolder:t,folderPath:a}){return e.reduce((e,r)=>e.then(()=>archivePath({path:r,folderPath:a,archiveFolder:t})),Promise.resolve())}async function unarchive({archiveFolder:e,unarchivedFolder:t}){const{file:a=[],directory:r=[]}=await getFolderContent({path:e,classified:!0}),o=r.map(a=>a.replace(e,t)),i=a.map(a=>({source:a,destination:a.replace(e,t)})),n=o.length&&o.reduce((e,t)=>e.then(()=>createFolder({path:t})),Promise.resolve())||createFolder({path:t});await n,await Promise.all(i.map(copyFile))}var removeFile=({path:e})=>new Promise((t,a)=>fs.unlink(e,e=>e?a(e):t())),removeFolder=({path:e})=>new Promise((t,a)=>fs.rmdir(e,e=>e?a(e):t()));async function permanentRemove({path:e}){const t=await getPathData(e),{file:a=[],directory:r=[]}=await getFolderContent({path:e,classified:!0}),o=new Set(t.isFile()?a.concat([e]):a),i=new Set(r.reverse().concat([e]));await Promise.all(Array.from(o).map(e=>removeFile({path:e}))),await Array.from(i).reduce((e,t)=>e.then(()=>removeFolder({path:t})),Promise.resolve())}async function removeFolder$1({path:e,exclude:t,excludePattern:a=""}){const r=(t&&"string"==typeof t&&[t]||t||[]).map(t=>`^${path.resolve(e,t)}$`).concat([a]).filter(e=>e).map(e=>new RegExp(e)),o=await getTempFolder({path:path.basename(e)}),i=getPathsToExclude({paths:await getFolderContent({path:e}),regex:r});await archivePaths({paths:i,folderPath:e,archiveFolder:o}),await removePaths({paths:[e]}),await unarchive({archiveFolder:o,unarchivedFolder:e}),await permanentRemove({path:o})}async function remove$1({file:e,files:t,folder:a,exclude:r,excludePattern:o}){e?await removePaths({paths:[e]}):t?await removePaths({paths:t}):a&&await removeFolder$1({path:a,exclude:r,excludePattern:o})}module.exports=remove$1;
//# sourceMappingURL=remove.js.map
