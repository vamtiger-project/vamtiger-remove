{"version":3,"file":"bin.js","sources":["../source/remove-paths.ts","../source/get-temp-folder.ts","../source/get-paths-to-exclude.ts","../source/archive-path.ts","../source/archive-paths.ts","../source/unarchive.ts","../source/remove-file.ts","../source/index.ts","../source/remove-folder-path.ts","../source/remove-path.ts","../source/remove-folder.ts","../source/remove.ts","../source/bin.ts"],"sourcesContent":["import { RemoveFiles } from '.';\n\nconst remove = require('trash');\n\nexport default async function ({ paths }: RemoveFiles.Params) {\n    const result = paths && await remove(paths);\n\n    return result;\n}","import { mkdtemp } from 'fs';\nimport { tmpdir } from 'os';\nimport { resolve as resolvePath } from 'path';\nimport { IGetTempFolder } from '.';\n\nexport default ({ path: folder }: IGetTempFolder['params']) => new Promise((resolve, reject) => {\n    const tempFolder = resolvePath(\n        tmpdir(),\n        folder\n    );\n\n    mkdtemp(tempFolder, (error, folder) => error ? reject(error) : resolve(folder))\n}) as Promise<string>;","import { IGetPathsToExclude } from '.';\n\nexport default function ({ paths, regex }: IGetPathsToExclude['params']) {\n    const pathsToExclude = new Set<string>();\n\n    let excludePath: boolean;\n\n    paths.forEach(currentPath => {\n        excludePath = !pathsToExclude.has(currentPath) && regex.some(currentRegex => currentPath.match(currentRegex) ? true : false);\n\n        if (excludePath) {\n            pathsToExclude.add(currentPath);\n        }\n    });\n\n    return Array.from(pathsToExclude);\n}","import { dirname, basename, resolve as resolvePath } from 'path';\nimport getPathData from 'vamtiger-get-path-data';\nimport createFolder from 'vamtiger-create-directory-recursive';\nimport copyFile from 'vamtiger-copy-file';\nimport { IArchivePath } from '.';\n\nexport default async function({ path: currentPath, archiveFolder, folderPath: sourceFolderPath }: IArchivePath['params']) {\n    const pathData = await getPathData(currentPath);\n    const filePath = pathData.isFile() && currentPath;\n    const archiveFilePath = filePath && filePath.replace(sourceFolderPath, archiveFolder);\n    const folderPath = archiveFilePath && dirname(archiveFilePath) || currentPath.replace(sourceFolderPath, archiveFolder);\n\n    if (folderPath) {\n        await createFolder({\n            path: folderPath\n        });\n    }\n\n    if (filePath && archiveFilePath) {\n        await copyFile({\n            source: filePath,\n            destination: archiveFilePath\n        });\n    }\n}","import archivePath from './archive-path';\nimport { IArchivePaths } from '.';\n\nexport default function ({ paths, archiveFolder, folderPath }: IArchivePaths['params']) {\n    const archivePaths = paths.reduce((archive, currentPath) => archive.then(() => archivePath({\n        path: currentPath,\n        folderPath,\n        archiveFolder\n    })), Promise.resolve());\n\n    return archivePaths;\n}","import getFolderContent from 'vamtiger-get-directory-content-recursive';\nimport createFolder from 'vamtiger-create-directory-recursive';\nimport copyFile from 'vamtiger-copy-file';\nimport { IUnArchive } from '.';\n\n\nexport default async function ({ archiveFolder, unarchivedFolder }: IUnArchive['params']) {\n    const { file: archivedFiles = [], directory: archiveFolders = [] } = await getFolderContent({\n        path: archiveFolder,\n        classified: true\n    }) as { file: string[], directory: string[]};\n    const unarchivedFoldersPaths = archiveFolders.map(currentArchivedFolder => currentArchivedFolder.replace(archiveFolder, unarchivedFolder));\n    const copyFilePaths = archivedFiles.map(currentArchivedFile => ({\n        source: currentArchivedFile,\n        destination: currentArchivedFile.replace(archiveFolder, unarchivedFolder)\n    }));\n    const unarchivedFolders = unarchivedFoldersPaths.length && unarchivedFoldersPaths.reduce((unarchive, currentPath) => unarchive.then(() => createFolder({\n            path: currentPath\n        })), Promise.resolve())\n        ||\n        createFolder({\n            path: unarchivedFolder\n        });\n\n    await unarchivedFolders;\n\n    await Promise.all(copyFilePaths.map(copyFile));\n}","import { unlink as removeFile } from 'fs';\nimport {\n    RemoveFile\n} from '.';\n\nexport default ({ path: filePath }: RemoveFile.Params) => new Promise((resolve, reject) =>\n    removeFile(filePath, error => error ? reject(error) : resolve())\n);","import { promisify } from 'util';\nimport { unlink, rmdir, PathLike } from 'fs';\nimport { ClassifiedDirectoryContent } from 'vamtiger-get-directory-content-recursive/build/directory-content';\nimport remove from './remove';\n\nexport type DirectoryContent = {\n    [K in keyof ClassifiedDirectoryContent]?: ClassifiedDirectoryContent[K];\n};\n\nexport type DirectoryContentKey = keyof ClassifiedDirectoryContent;\n\nexport type CurrentDirectoryContent = ClassifiedDirectoryContent[DirectoryContentKey] | string[] | undefined;\n\nexport enum CommandlineArg {\n    file = 'file',\n    folder = 'folder',\n    exclude = 'exclude',\n    excludePattern = 'excludePattern',\n    help = 'help'\n}\n\nexport enum AbbreviatedCommandlineArg {\n    f = 'f',\n    d = 'd',\n    e = 'e',\n    p = 'p',\n    h = 'h'\n}\n\nexport const ShortCommandlineArgs = {\n    [CommandlineArg.file]: AbbreviatedCommandlineArg.f,\n    [CommandlineArg.folder]: AbbreviatedCommandlineArg.d,\n    [CommandlineArg.exclude]: AbbreviatedCommandlineArg.e,\n    [CommandlineArg.excludePattern]: AbbreviatedCommandlineArg.p,\n    [CommandlineArg.help]: AbbreviatedCommandlineArg.h\n}\n\nexport const CommandlineDescription = {\n    [CommandlineArg.file]: 'File to remove',\n    [CommandlineArg.folder]: 'Folder to remove',\n    [CommandlineArg.exclude]: 'File/Folder to exclude',\n    [CommandlineArg.excludePattern]: 'File/Folder pattern to exclude',\n    [CommandlineArg.help]: 'List help options'\n}\n\nexport namespace RemoveFile {\n    export type Params = {\n        path: PathLike;\n    }\n}\n\nexport namespace RemoveFiles {\n    export type Params = {\n        paths: Remove.Params['files'];\n    }\n}\n\nexport namespace RemoveFolder {\n    export type Params = {\n        path: string;\n        exclude: Remove.Params['exclude'];\n        excludePattern: Remove.Params['excludePattern'];\n    }\n}\n\nexport namespace GetFilePath {\n    export type Params = {\n        path: string;\n    }\n}\n\nexport namespace GetFolderContent {\n    export type Params = {\n        folderPath: RemoveFolder.Params['path'];\n        exclude?: string;\n        excludePattern?: string;\n    }\n}\n\nexport namespace Remove {\n    export type Params = {\n        file?: string;\n        folder?: string;\n        files?: string[];\n        recursive?: boolean;\n        exclude?: string | string[];\n        excludePattern?: string;\n    }\n}\n\nexport interface IGetTempFolder {\n    params: {\n        path: string;\n    }\n}\n\nexport interface IGetPathsToExclude {\n    params: {\n        paths: string[];\n        regex: RegExp[];\n    }\n}\n\nexport interface IArchivePaths {\n    params: {\n        paths: string[];\n        folderPath: string;\n        archiveFolder: string;\n    }\n}\n\nexport interface IArchivePath {\n    params: {\n        path: string;\n        folderPath: string;\n        archiveFolder: string;\n    }\n}\n\nexport interface IUnArchive {\n    params: {\n        archiveFolder: string;\n        unarchivedFolder: string;\n    }\n}\n\nexport interface IRemovePath {\n    params: {\n        path: string;\n    }\n}\n\nexport interface IRemoveFolderPath {\n    params: {\n        path: string;\n    }\n}\n\nexport default remove;","import { rmdir as removeFolder } from 'fs';\nimport { IRemoveFolderPath } from '.';\n\nexport default ({ path: folderPath }: IRemoveFolderPath['params']) => new Promise((resolve, reject) =>\n    removeFolder(folderPath, error => error ? reject(error) : resolve())\n) as Promise<void>;","import getFolderContent from 'vamtiger-get-directory-content-recursive';\nimport getPathData from 'vamtiger-get-path-data';\nimport removeFile from './remove-file';\nimport removeFolder from './remove-folder-path';\nimport { IRemovePath } from '.';\nimport { promises } from 'fs';\n\nexport default async function ({ path: currentPath}: IRemovePath['params']) {\n    const pathData = await getPathData(currentPath);\n    const { file = [], directory = [] } = await getFolderContent({\n        path: currentPath,\n        classified: true\n    }) as { file: string[], directory: string[]};\n    const files = new Set(pathData.isFile() ? file.concat([currentPath]) : file);\n    const folders = new Set(\n        directory\n            .reverse()\n            .concat([currentPath])\n    );\n\n    await Promise.all(Array.from(files).map(filePath => removeFile({\n        path: filePath\n    })));\n\n    await Array\n        .from(folders)\n        .reduce((removeCurrentFolder, folderPath) => removeCurrentFolder.then(() => removeFolder({\n            path: folderPath\n        })), Promise.resolve());\n}","import { basename, resolve as resolvePath } from 'path';\nimport getFolderContent from 'vamtiger-get-directory-content-recursive';\nimport removePaths from './remove-paths';\nimport getTempFolder from './get-temp-folder';\nimport getPathsToExclude from './get-paths-to-exclude';\nimport archivePaths from './archive-paths';\nimport unarchive from './unarchive';\nimport permanentRemove from './remove-path';\nimport { RemoveFolder } from '.';\n\nexport default async function ({ path: folderPath, exclude, excludePattern = '' }: RemoveFolder.Params) {\n    const excludePatterns = (exclude && typeof exclude === 'string' && [exclude] || exclude || []) as string[];\n    const patterns = excludePatterns\n        .map(pattern => `^${resolvePath(folderPath, pattern)}$`)\n        .concat([excludePattern])\n        .filter(pattern => pattern) as string[];\n    const excludeRegex = patterns.map(pattern => new RegExp(pattern));\n    const tempFolder = await getTempFolder({\n        path: basename(folderPath)\n    });\n    const folderContent = await getFolderContent({ path: folderPath }) as string[];\n    const pathsToExclude = getPathsToExclude({\n        paths: folderContent,\n        regex: excludeRegex\n    });\n\n    await archivePaths({\n        paths: pathsToExclude,\n        folderPath,\n        archiveFolder: tempFolder\n    });\n\n    await removePaths({\n        paths: [folderPath]\n    });\n\n    await unarchive({\n        archiveFolder: tempFolder,\n        unarchivedFolder: folderPath\n    });\n\n    await permanentRemove({\n        path: tempFolder\n    });\n}","import removePaths from './remove-paths';\nimport removeFolder from './remove-folder';\nimport {\n    Remove\n} from '.';\n\nexport default async function remove({ file, files, folder, exclude, excludePattern }: Remove.Params) {\n    if (file) {\n        await removePaths({\n            paths: [file]\n        });\n    } else if (files) {\n        await removePaths({\n            paths: files\n        });\n    } else if (folder) {\n        await removeFolder({\n            path: folder,\n            exclude,\n            excludePattern\n        });\n    }\n}","import { resolve as resolvePath, resolve } from 'path';\nimport Args from 'vamtiger-argv/build/main';\nimport getHelp from 'vamtiger-commandline-help';\nimport remove, {\n    CommandlineArg,\n    ShortCommandlineArgs,\n    CommandlineDescription\n} from '.';\n\nconst workingDirectory = process.cwd();\nconst args = new Args();\nconst currentFiles = (args.has(CommandlineArg.file) && args.getAll(CommandlineArg.file)\n    || args.has(ShortCommandlineArgs[CommandlineArg.file]) && args.getAll(ShortCommandlineArgs[CommandlineArg.file])) as string[];\nconst currrentFolder = (args.has(CommandlineArg.folder) && args.get(CommandlineArg.folder)\n    || args.has(ShortCommandlineArgs[CommandlineArg.folder]) && args.get(ShortCommandlineArgs[CommandlineArg.folder])) as string;\nconst currentExclude = (args.has(CommandlineArg.exclude) && args.getAll(CommandlineArg.exclude)\n    || args.has(ShortCommandlineArgs[CommandlineArg.exclude]) && args.getAll(ShortCommandlineArgs[CommandlineArg.exclude])) as string[];\nconst currrentFolderPattern = (args.has(CommandlineArg.excludePattern) && args.get(CommandlineArg.excludePattern)\n    || args.has(ShortCommandlineArgs[CommandlineArg.excludePattern]) && args.get(ShortCommandlineArgs[CommandlineArg.excludePattern])) as string;\nconst help = (args.has(CommandlineArg.help) || args.has(ShortCommandlineArgs[CommandlineArg.help])) && getHelp({\n    args: Object.assign(CommandlineArg),\n    short: ShortCommandlineArgs,\n    description: CommandlineDescription\n});\nconst removeParams = (currentFiles || currrentFolder) && {\n    files: currentFiles && currentFiles.map(file => resolvePath(workingDirectory, file)),\n    folder: resolvePath(workingDirectory, currrentFolder),\n    exclude: currentExclude,\n    excludePattern: currrentFolderPattern\n};\n\nif (help) {\n    console.log(help);\n} else if (removeParams) {\n    remove(removeParams)\n        .catch(handleError);\n}\n\nfunction handleError(error: Error) {\n    console.trace(error);\n    process.exit();\n}"],"names":["remove","require","paths","path","folder","Promise","resolve","reject","tempFolder","resolvePath","tmpdir","mkdtemp","error","regex","pathsToExclude","Set","excludePath","forEach","currentPath","has","some","currentRegex","match","add","Array","from","archiveFolder","folderPath","sourceFolderPath","filePath","getPathData","isFile","archiveFilePath","replace","dirname","createFolder","copyFile","source","destination","reduce","archive","then","archivePath","unarchivedFolder","file","archivedFiles","directory","archiveFolders","getFolderContent","classified","unarchivedFoldersPaths","map","currentArchivedFolder","copyFilePaths","currentArchivedFile","length","unarchive","all","CommandlineArg","AbbreviatedCommandlineArg","removeFile","removeFolder","pathData","files","concat","folders","reverse","removeCurrentFolder","exclude","excludePattern","excludeRegex","pattern","filter","RegExp","getTempFolder","basename","archivePaths","getPathsToExclude","removePaths","permanentRemove","ShortCommandlineArgs","[object Object]","f","d","e","p","help","h","CommandlineDescription","workingDirectory","process","cwd","args","Args","currentFiles","getAll","currrentFolder","get","currentExclude","currrentFolderPattern","getHelp","Object","assign","short","description","removeParams","handleError","console","trace","exit","log","catch"],"mappings":"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"}